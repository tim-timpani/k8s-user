import argparse
import base64
from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.x509.oid import NameOID
from dataclasses import dataclass
from datetime import datetime, timezone, timedelta
from kubernetes import client, config, utils
import logging
import os
import time
import tempfile
import yaml

DEF_KUBECONFIG = os.getenv("KUBECONFIG", os.path.expanduser("~/.kube/config"))
CLUSTER_USER = "qa-monitor"
KUBECTL_CMD = "kubectl"
EPILOG = f"""Script to generate a monitor (readonly) kubeconfig from an existing
kubeconfig that has full access.  This script will create a new role and
rolebinding.  A default user name '{CLUSTER_USER}' is created and a certificate issued.
WARNING: If a previous rolebinding/cert was issued to this user, it will be overwritten.
Any previous kubeconfigs generated by this script for that user will be no longer valid."""


@dataclass
class ClusterRoleRule:
    groups: list[str]
    resources: list[str]
    verbs: list[str]


# These rules are not advised for hardened security, just a safeguard.  Normally specific resources
# for each api group are specified for seriously hardened security to only those resources that are
# needed. Protect the kubeconfig file generated using these rules.
DEFAULT_RULES = [
    ClusterRoleRule(groups=["*"], resources=["*"], verbs=["list", "get", "watch"])
]
logger = logging.getLogger(os.path.basename(__file__))


class KubeConfig:

    def __init__(self, admin_config_path: str, monitor_user: str = CLUSTER_USER,
                 existing_role: (None, str) = None, context: (None, str) = None):

        self.admin_config_path = admin_config_path
        self.monitor_user = monitor_user
        self.existing_role = existing_role

        config.load_kube_config(config_file=admin_config_path, context=context)
        self.k8s_client = client.ApiClient()

        with open(admin_config_path, "r") as fh:
            self.config_data = yaml.safe_load(fh)

        # Currently, multiple contexts are not supported
        if len(self.config_data['clusters']) > 1:
            raise RuntimeError(f"Config file {admin_config_path} contains multiple contexts")
        self.cluster_index = 0

    @property
    def cluster_name(self) -> str:
        """cluster name is retrieved from source kubeconfig"""
        return self.config_data['clusters'][self.cluster_index]['name']

    @property
    def cluster_server(self) -> str:
        """server is retrieved from source kubeconfig"""
        return self.config_data['clusters'][self.cluster_index]['cluster']['server']

    @property
    def k8s_ca(self) -> str:
        """k8s ca is retrieved from source kubeconfig"""
        return self.config_data['clusters'][self.cluster_index]['cluster']['certificate-authority-data']

    @property
    def role_name(self) -> str:
        """role name is derived from user name unless provided"""
        if self.existing_role is None:
            return f"{self.monitor_user}-role"
        return self.existing_role

    @property
    def role_binding_name(self) -> str:
        """
        role binding name is derived from both user and role which is redundant in some cases
        but helpful in others
        """
        return f"{self.monitor_user}-{self.role_name}"

    @property
    def cert_request_name(self) -> str:
        """cert request is based from user name"""
        return f"{self.monitor_user}-cr"

    @property
    def run_env(self) -> dict:
        """run environement for kubectl commands"""
        run_env = os.environ.copy()
        run_env["KUBECONFIG"] = self.admin_config_path
        return run_env

    def generate_csr(self) -> tuple[bytes, str]:

        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096,
            backend=default_backend()
        )
        b = x509.CertificateSigningRequestBuilder()
        req = b.subject_name(x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, u"US"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, u"NC"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, u"RTP"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, u"NetApp"),
            x509.NameAttribute(NameOID.COMMON_NAME, self.monitor_user)
        ])).sign(private_key, hashes.SHA256(), default_backend())

        cert = req.public_bytes(encoding=serialization.Encoding.PEM)

        pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.TraditionalOpenSSL,
            encryption_algorithm=serialization.NoEncryption()
        ).decode('utf-8')

        return cert, pem

    def apply_dict_to_k8s(self, resource_data: dict):
        utils.create_from_dict(
            k8s_client=self.k8s_client,
            data=resource_data
        )

    def approve_k8s_csr(self) -> bytes:

        certs_api = client.CertificatesV1beta1Api()

        # Get the CSR
        body = certs_api.read_certificate_signing_request_status(self.cert_request_name)

        # create an approval condition
        approval_condition = client.V1beta1CertificateSigningRequestCondition(
            last_update_time=datetime.now(timezone.utc).astimezone(),
            message='This certificate was approved by Python Client API',
            reason='MyOwnReason',
            type='Approved')

        # patch the existing `body` with the new conditions
        # you might want to append the new conditions to the existing ones
        body.status.conditions = [approval_condition]

        # patch the Kubernetes object
        response = certs_api.replace_certificate_signing_request_approval(
            self.cert_request_name,
            body
        )

        start_timer = datetime.now()
        while response.status.certificate is None:
            time.sleep(5)
            if datetime.now() - start_timer > timedelta(seconds=300):
                raise TimeoutError("Timeout waiting for certificate")
            response = certs_api.read_certificate_signing_request_status(
                name=self.cert_request_name
            )

        signed_cert = base64.b64decode(response.status.certificate)

        return signed_cert

    def get_config_data(self, client_cert: bytes, client_key: bytes, config_id: str = ""):
        if config_id == "":
            config_id = self.cluster_name
        with open(self.k8s_client.configuration.ssl_ca_cert, "rb") as fh:
            ca_data = fh.read()
        cluster_config = {
            'apiVersion': 'v1',
            'clusters': [
                {
                    'cluster': {
                        'certificate-authority-data': base64.b64encode(ca_data).decode('utf-8'),
                        'server': self.k8s_client.configuration.host
                    },
                    'name': config_id
                }
            ],
            'contexts': [
                {
                    'context': {
                        'cluster': self.cluster_name,
                        'user': self.monitor_user,
                        'namespace': 'default'
                    },
                    'name': config_id
                }
            ],
            'current-context': config_id,
            'kind': 'Config',
            'preferences': {},
            'users': [
                {
                    'name': self.monitor_user,
                    'user': {
                        'client-certificate-data': base64.b64encode(client_cert).decode('utf-8'),
                        'client-key-data': base64.b64encode(client_key).decode('utf-8')
                    }
                }
            ]
        }
        return cluster_config

    def apply_cluster_role(self, rules: (None, list[ClusterRoleRule]) = None):
        """Create a cluster role for readonly access"""
        if rules is None:
            rules = DEFAULT_RULES
        logger.info(f"Applying cluster role {self.role_name} to k8s")
        cluster_role = {
            "apiVersion": "rbac.authorization.k8s.io/v1",
            "kind": "ClusterRole",
            "metadata": {
                "name": self.role_name
            },
            "rules": []
        }
        for rule in rules:
            cluster_role["rules"].append({
                "apiGroups": rule.groups,
                "resources": rule.resources,
                "verbs": rule.verbs
            })
        self.apply_dict_to_k8s(cluster_role)
        return self.role_name

    def create_role_binding(self):
        """Creates a cluster role binding for the user"""
        logging.info(f"Creating cluster role binding for user {self.monitor_user} to role {self.role_name}")
        role_binding = {
            "apiVersion": "rbac.authorization.k8s.io/v1",
            "kind": "ClusterRoleBinding",
            "metadata": {
                "name": self.role_binding_name
            },
            "roleRef": {"kind": "ClusterRole", "name": self.role_name},
            "subjects": [{"kind": "User", "name": self.monitor_user}]
        }
        self.apply_dict_to_k8s(role_binding)
        return self.role_binding_name

    def generate_and_approve_cert(self, cert_file_name: str, key_file_name: str):
        """
        Create a certificate for k8s authentication
        :param cert_file_name: Path where the cert file will be saved
        :param key_file_name: Path where the private key will be saved
        :return:
        """

        # Check for existing cert
        certs_api = client.CertificatesV1beta1Api()
        response = certs_api.read_certificate_signing_request_status(
            name=self.cert_request_name
        )
        if response.status.certificate is not None:
            logger.warning(f"Deleting existing csr '{self.cert_request_name}'")
            certs_api.delete_certificate_signing_request(name=self.cert_request_name)

        logging.info(f"Generating cert request {self.cert_request_name}")
        cr, pem = self.generate_csr()

        with open(key_file_name, "w") as fh:
            fh.write(pem)

        # Apply the cert request to k8s
        cert_request = {
            "apiVersion": "certificates.k8s.io/v1",
            "kind": "CertificateSigningRequest",
            "metadata": {"name": self.cert_request_name},
            "spec": {
                "signerName": "kubernetes.io/kube-apiserver-client",
                "request": base64.b64encode(cr).decode('utf-8'),
                "usages": ["client auth"]
            }
        }
        self.apply_dict_to_k8s(cert_request)

        # Approve the certificate
        logging.info(f"Approving cert request {self.cert_request_name}")
        # self.run_kubectl(["certificate", "approve", self.cert_request_name])

        # Get the signed cert and save it to file
        # result = self.run_kubectl(["get", "csr", self.cert_request_name, "-o", "yaml"])
        # cert_data = yaml.safe_load(result)

        # user_cert = cert_data["status"]["certificate"]

        user_cert = self.approve_k8s_csr()

        with open(cert_file_name, "wb") as fp:
            # fp.write(base64.b64decode(user_cert))
            fp.write(user_cert)

    def create_new_kubeconfig(self, cert_file: str, cert_key_file: str, output_file: str):
        """
        Creates the new monitor kubeconfig file
        :param cert_file: path to existing monitor user cert
        :param cert_key_file: path to existing key for user cert
        :param output_file: path to new kubeconfig file to be created
        :return: None
        """

        logger.info(f"Creating new kubeconfig file {output_file}")

        with open(cert_file, "rb") as fh:
            cert = fh.read()

        with open(cert_key_file, "rb") as fh:
            key = fh.read()

        config_data = self.get_config_data(client_cert=cert, client_key=key)
        with open(output_file, "w") as fh:
            yaml.safe_dump(config_data, fh)

    def generate_monitor_config(self, config_file: str):
        """
        Main logic to generate a monitor (readonly) kubeconfig file
        :param config_file: Path to create the new monitor config file
        :return: None
        """

        rbac_api = client.RbacAuthorizationV1Api(self.k8s_client)

        # Check if role/binding already exists
        bindings = [b.metadata.name for b in rbac_api.list_cluster_role_binding().items]
        if self.role_binding_name in bindings:
            ans = input(f"Cluster role binding '{self.role_binding_name}' already exists, overwrite? (y/N)")
            if ans not in ("y", "Y"):
                logger.info("Terminating script by user")
                return
            logger.info(f"Deleting clusterrolebinding '{self.role_binding_name}'")
            rbac_api.delete_cluster_role_binding(name=self.role_binding_name)

        roles = [r.metadata.name for r in rbac_api.list_cluster_role().items]
        if self.role_name in roles and not self.existing_role:
            ans = input(f"Cluster role '{self.role_name}' already exists, overwrite? (y/N)")
            if ans not in ("y", "Y"):
                logger.info("Terminating script by user")
                return
            logger.info(f"Deleting clusterrole '{self.role_name}'")
            rbac_api.delete_cluster_role(name=self.role_name)
        elif self.existing_role and self.role_name not in roles:
            raise RuntimeError(f"Role {self.existing_role} specified but does not exist")

        # Create the monitor role/binding in k8s
        if self.existing_role is None:
            self.apply_cluster_role()
        self.create_role_binding()

        # Create a temp directory for the cert files
        with tempfile.TemporaryDirectory() as temp_dir:
            cert_file = os.path.join(temp_dir, "monitor.crt")
            cert_key_file = os.path.join(temp_dir, "monitor.key")

            # Create the cert request and approve it, saving the cert and key files
            self.generate_and_approve_cert(
                cert_file_name=cert_file,
                key_file_name=cert_key_file
            )

            self.create_new_kubeconfig(
                cert_file=cert_file,
                cert_key_file=cert_key_file,
                output_file=config_file
            )


def get_args():
    """Get the command line arguments"""
    parser = argparse.ArgumentParser(description="Create user kubeconfig", epilog=EPILOG)
    parser.add_argument(
        "outfile",
        help="Output file name"
    )
    parser.add_argument(
        "--kubeconfig", "-k",
        default=DEF_KUBECONFIG,
        help=f"Source path to kubeconfig with full access default={DEF_KUBECONFIG}"
    )
    parser.add_argument(
        "--user", "-u",
        default=CLUSTER_USER,
        help=f"K8s user to create/overwrite default={CLUSTER_USER}"
    )
    parser.add_argument(
        "--role", "-r",
        required=False,
        help=f"Existing K8s role to bind to user. Omit to create a role that uses default list/get/watch rules"
    )
    return parser.parse_args()


def main():
    args = get_args()
    logging.basicConfig(level=logging.INFO)
    kube_config = KubeConfig(
        admin_config_path=os.path.expanduser(args.kubeconfig),
        monitor_user=args.user,
        existing_role=args.role
    )
    kube_config.generate_monitor_config(args.outfile)


if __name__ == "__main__":
    main()
